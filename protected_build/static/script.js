c.l('script.js loaded'); function showLoader() { const button = d.q('button[type="submit"]'); button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Загрузка...'; button.disabled = true; } function hideLoader() { const button = d.q('button[type="submit"]'); button.innerHTML = 'Запустить'; button.disabled = false; } function showNotification(message, type = 'success') { const toast = ` <div class="toast-container position-fixed bottom-0 end-0 p-3"> <div class="toast align-items-center text-white bg-${type}" role="alert"> <div class="d-flex"> <div class="toast-body"> ${message} </div> <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button> </div> </div> </div> `; d.body.insertAdjacentHTML('beforeend', toast); const toastElement = d.q('.toast'); const bsToast = new bootstrap.Toast(toastElement); bsToast.show(); } d.a('DOMContentLoaded', function() { const form = d.g('settingsForm'); if (form) { form.a('submit', function(e) { e.preventDefault(); showLoader(); const formData = { port: d.g('port').value, frequency: d.g('frequency').value, timer: { enabled: d.g('timerEnabled').checked, value: d.g('timerValue').value } }; f('/start', { method: 'POST', headers: { 'Content-Type': 'application/j', }, body: JSON.stringify(formData) }) .t(r => r.j()) .t(data => { hideLoader(); showNotification('Настройки успешно применены', 'success'); }) .h(e => { hideLoader(); showNotification('Произошла ошибка: ' + e.message, 'danger'); }); }); } }); d.a('DOMContentLoaded', () => { function updateTime() { const now = new Date(); const timeString = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }); const timeElement = d.g('current-time'); if (timeElement) { timeElement.textContent = timeString; } } updateTime(); setInterval(updateTime, 1000); d.qAll('.nav-tab').forEach(tab => { tab.a('click', () => { d.qAll('.nav-tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); const tabName = tab.dataset.tab; c.l('Switched to tab:', tabName); }); }); function handleNumericInput(input) { input.a('input', (e) => { let value = e.target.value.replace(/[^0-9.]/g, ''); if (value.split('.').length > 2) value = value.replace(/\.+$/, ''); e.target.value = value; }); } function updateOffset2Min() { const pw1 = parseFloat(pulseWidth1.value); const off1 = parseFloat(offset1.value); const safePw1 = isNaN(pw1) ? 0 : pw1; const safeOff1 = isNaN(off1) ? 0 : off1; const interlock = parseFloat(d.g('interlock-input').value) || 0; const minVal = safePw1 + safeOff1 + interlock; offset2.min = minVal; offset2.value = minVal; offset2.dispatchEvent(new Event('input')); } function updateOffset4Min() { const pw3 = parseFloat(pulseWidth3.value); const off3 = parseFloat(offset3.value); const safePw3 = isNaN(pw3) ? 0 : pw3; const safeOff3 = isNaN(off3) ? 0 : off3; const interlock = parseFloat(d.g('interlock-input').value) || 0; const minVal = safePw3 + safeOff3 + interlock; offset4.min = minVal; offset4.value = minVal; offset4.dispatchEvent(new Event('input')); } let pingTimeout; let failedPings = 0; const MAX_FAILED_PINGS = 3; const PING_INTERVAL = 5000; async function doPing() { try { c.l('Sending ping...'); const r = await f('/ping'); if (r.ok) { c.l('Ping successful'); failedPings = 0; } else { c.e('Ping failed with status:', r.status); handleFailedPing(); } } h (e) { c.e('Ping failed:', e); handleFailedPing(); } pingTimeout = setTimeout(doPing, PING_INTERVAL); } function startPing() { if (pingTimeout) { clearTimeout(pingTimeout); } failedPings = 0; c.l('Starting ping mechanism...'); doPing(); } function handleFailedPing() { failedPings++; c.w(`Failed pings: ${failedPings}/${MAX_FAILED_PINGS}`); if (failedPings >= MAX_FAILED_PINGS) { c.e('Connection lost. Attempting to reconnect...'); startPing(); } } startPing(); const periodInput = d.g('period-input'); const frequencyInput = d.g('frequency-input'); periodInput.a('input', () => { const period = parseFloat(periodInput.value); if (period > 0) { const frequency = (1 / period) * 1000000; frequencyInput.value = frequency.toFixed(2); } else { frequencyInput.value = ''; } updateOffset2Min(); updateOffset4Min(); }); frequencyInput.a('input', () => { const frequency = parseFloat(frequencyInput.value); if (frequency > 0) { const period = (1 / frequency) * 1000000; periodInput.value = period.toFixed(2); } else { periodInput.value = ''; } updateOffset2Min(); updateOffset4Min(); }); d.a('visibilitychange', () => { if (d.visibilityState === 'visible') { c.l('Tab became visible, restarting ping'); startPing(); } }); window.a('beforeunload', () => { if (pingTimeout) { clearTimeout(pingTimeout); } try { const xhr = new XMLHttpRequest(); xhr.open('GET', '/ping', false); xhr.send(); } h (e) { c.e('Final ping failed:', e); } }); d.qAll('input[type="text"]:not(#port-select):not(.modal-input)').forEach(input => { handleNumericInput(input); }); d.qAll('.channel-toggle').forEach(toggle => { const channelCard = toggle.closest('.channel-card'); const channelNum = parseInt(toggle.dataset.channel); const slider = toggle.nextElementSibling; const inputs = channelCard.qAll('input[type="text"]:not(.pulse-value)'); const mainInput = channelCard.q('.pulse-value'); toggle.a('change', () => { if (!toggle.checked) { slider.classList.add('slider-off'); } else { slider.classList.remove('slider-off'); } if (toggle.checked) { channelCard.classList.remove('disabled'); } else { channelCard.classList.add('disabled'); } inputs.forEach(input => { input.disabled = !toggle.checked; }); if (mainInput) { mainInput.disabled = !toggle.checked; } if (channelNum === 1) { const interlockToggle = channelRow.q('.interlock-toggle'); if (interlockToggle) interlockToggle.disabled = !toggle.checked; channelRow.qAll('.channels-dropdown-item input[type="checkbox"]').forEach(cb => { cb.disabled = !toggle.checked; }); channelRow.qAll('.channels-btn').forEach(btn => { btn.disabled = !toggle.checked; }); const dropdown = channelRow.q('.channels-dropdown-selected'); if (dropdown) { if (!toggle.checked) { dropdown.setAttribute('tabindex', '-1'); dropdown.classList.add('disabled'); } else { dropdown.setAttribute('tabindex', '0'); dropdown.classList.remove('disabled'); } } } const pos = channelCard.q('.channel-polarity.positive'); const neg = channelCard.q('.channel-polarity.negative'); if (toggle.checked) { if (pos) pos.classList.remove('label-dimmed'); if (neg) neg.classList.remove('label-dimmed'); } else { if (pos) pos.classList.add('label-dimmed'); if (neg) neg.classList.add('label-dimmed'); } }); if (!toggle.checked) { slider.classList.add('slider-off'); channelCard.classList.add('disabled'); inputs.forEach(input => input.disabled = true); if (mainInput) mainInput.disabled = true; if (channelNum === 1) { const interlockToggle = channelRow.q('.interlock-toggle'); if (interlockToggle) interlockToggle.disabled = false; channelRow.qAll('.channels-dropdown-item input[type="checkbox"]').forEach(cb => { cb.disabled = false; }); channelRow.qAll('.channels-btn').forEach(btn => { btn.disabled = false; }); const dropdown = channelRow.q('.channels-dropdown-selected'); if (dropdown) { dropdown.setAttribute('tabindex', '0'); dropdown.classList.remove('disabled'); } } const pos = channelCard.q('.channel-polarity.positive'); const neg = channelCard.q('.channel-polarity.negative'); if (pos) pos.classList.add('label-dimmed'); if (neg) neg.classList.add('label-dimmed'); if (channelNum === 1) { const interlockToggle = channelRow.q('.interlock-toggle'); if (interlockToggle) interlockToggle.disabled = true; channelRow.qAll('.channels-dropdown-item input[type="checkbox"]').forEach(cb => { cb.disabled = true; }); channelRow.qAll('.channels-btn').forEach(btn => { btn.disabled = true; }); const dropdown = channelRow.q('.channels-dropdown-selected'); if (dropdown) { dropdown.setAttribute('tabindex', '-1'); dropdown.classList.add('disabled'); } } } else { slider.classList.remove('slider-off'); channelCard.classList.remove('disabled'); inputs.forEach(input => { input.disabled = false; }); if (mainInput) mainInput.disabled = false; const pos = channelCard.q('.channel-polarity.positive'); const neg = channelCard.q('.channel-polarity.negative'); if (pos) pos.classList.remove('label-dimmed'); if (neg) neg.classList.remove('label-dimmed'); } }); function showModal(modalId) { const modal = d.g(modalId); modal.style.display = 'block'; const firstInput = modal.q('input[type="text"], textarea'); if (firstInput) { setTimeout(() => { firstInput.focus(); }, 100); } d.body.style.overflow = 'hidden'; } function hideModal(modalId) { d.g(modalId).style.display = 'none'; d.body.style.overflow = ''; } window.a('click', (event) => { if (event.target.classList.contains('modal')) { hideModal(event.target.id); } }); d.a('keydown', (event) => { if (event.key === 'Escape') { const openModals = d.qAll('.modal[style*="block"]'); openModals.forEach(modal => { hideModal(modal.id); }); } }); d.g('close-save-modal').a('click', () => { hideModal('save-recipe-modal'); }); d.g('close-load-modal').a('click', () => { hideModal('load-recipe-modal'); }); d.g('save-recipe').a('click', () => { showModal('save-recipe-modal'); }); d.g('load-recipe').a('click', () => { showModal('load-recipe-modal'); loadServerRecipes(); }); d.g('save-to-server').a('click', async () => { const settings = collectCurrentSettings(); const recipeName = d.g('recipe-name').value; settings.metadata = { name: recipeName || 'Unnamed Recipe', description: '', created: new Date().toISOString(), version: '1.0' }; try { const r = await f('/save-recipe', { method: 'POST', headers: { 'Content-Type': 'application/j' }, body: JSON.stringify(settings) }); const result = await r.j(); if (r.ok) { alert(`Recipe saved successfully as: ${result.filename}`); hideModal('save-recipe-modal'); d.g('recipe-name').value = ''; } else { throw new Error(result.e || 'Failed to save recipe'); } } h (e) { c.e('Error saving recipe:', e); alert('Error saving recipe: ' + e.message); } }); d.g('save-to-file').a('click', () => { const settings = collectCurrentSettings(); const recipeName = d.g('recipe-name').value; settings.metadata = { name: recipeName || 'Unnamed Recipe', description: '', created: new Date().toISOString(), version: '1.0' }; try { const filename = recipeName ? `${recipeName.replace(/[^a-zA-Z0-9]/g, '_')}.j` : 'pulse-generator-recipe.j'; const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/j' }); const url = URL.createObjectURL(blob); const a = d.createElement('a'); a.href = url; a.download = filename; d.body.appendChild(a); a.click(); d.body.removeChild(a); URL.revokeObjectURL(url); alert('Recipe downloaded successfully!'); hideModal('save-recipe-modal'); d.g('recipe-name').value = ''; } h (e) { c.e('Error downloading recipe:', e); alert('Error downloading recipe: ' + e.message); } }); d.g('browse-file').a('click', () => { d.g('file-input').click(); }); d.g('file-input').a('change', async (e) => { const file = e.target.files[0]; if (!file) return; try { const formData = new FormData(); formData.append('file', file); const r = await f('/load-recipe', { method: 'POST', body: formData }); const result = await r.j(); if (r.ok) { applyRecipeSettings(result.data); alert('Recipe loaded successfully!'); hideModal('load-recipe-modal'); } else { throw new Error(result.e || 'Failed to load recipe'); } } h (e) { c.e('Error loading recipe:', e); alert('Error loading recipe: ' + e.message); } }); function collectCurrentSettings() { const settings = { port: '/dev/serial0', period: Number(d.g('period-input').value), frequency: Number(d.g('frequency-input').value), timer: { enabled: d.g('timer-toggle').checked, value: Number(d.g('timer-input').value) }, interlock: Number(d.g('interlock-input').value), channels: [] }; for (let channel = 1; channel <= 4; channel++) { const mainInputClass = channel === 1 ? 'main-channel-input-1' : 'main-channel-input'; function safeValue(selector) { const el = d.q(selector); if (!el) { c.w('Element not found for selector:', selector); return 0; } return Number(el.value); } function safeChecked(selector) { const el = d.q(selector); if (!el) { c.w('Element not found for selector:', selector); return false; } return el.checked; } const channelData = { enabled: safeChecked(`.channel-toggle[data-channel="${channel}"]`), mainValue: safeValue(`.${mainInputClass}[data-channel="${channel}"]`), pulseWidth: safeValue(`.pulse-width-input[data-channel="${channel}"]`), offset: safeValue(`.offset-input[data-channel="${channel}"]`), power: safeValue(`.power-input[data-channel="${channel}"]`), voltage: safeValue(`.voltage-input[data-channel="${channel}"]`) }; if (channel === 1) { channelData.interlock = safeChecked(`.interlock-toggle[data-channel="1"]`); } settings.channels.push(channelData); } return settings; } function applyRecipeSettings(settings) { d.g('period-input').value = settings.period; d.g('frequency-input').value = settings.frequency; d.g('timer-toggle').checked = settings.timer.enabled; d.g('timer-toggle').dispatchEvent(new Event('change')); d.g('timer-input').value = settings.timer.value; if (settings.interlock !== undefined) { d.g('interlock-input').value = settings.interlock; updateOffset2Min(); updateOffset4Min(); } settings.channels.forEach((channel, index) => { const channelNum = index + 1; const mainInputClass = channelNum === 1 ? 'main-channel-input-1' : 'main-channel-input'; const toggle = d.q(`.channel-toggle[data-channel="${channelNum}"]`); if (toggle) { toggle.checked = channel.enabled; toggle.dispatchEvent(new Event('change')); } const mainInput = d.q(`.${mainInputClass}[data-channel="${channelNum}"]`); if (mainInput) { if (channel.mainValue !== undefined && channel.mainValue !== null) { mainInput.value = channel.mainValue; } else { mainInput.value = 0; } } d.q(`.pulse-width-input[data-channel="${channelNum}"]`).value = channel.pulseWidth; d.q(`.offset-input[data-channel="${channelNum}"]`).value = channel.offset; d.q(`.power-input[data-channel="${channelNum}"]`).value = channel.power; d.q(`.voltage-input[data-channel="${channelNum}"]`).value = channel.voltage; if (channelNum === 1 && channel.interlock !== undefined) { const interlockToggle = d.q(`.interlock-toggle[data-channel="1"]`); if (interlockToggle) { interlockToggle.checked = channel.interlock; } } }); } async function loadServerRecipes() { const recipesList = d.g('server-recipes-list'); recipesList.innerHTML = '<p>Loading recipes...</p>'; try { const r = await f('/list-recipes'); const result = await r.j(); if (r.ok) { if (result.recipes.length === 0) { recipesList.innerHTML = '<p>No recipes found on server.</p>'; return; } recipesList.innerHTML = ''; result.recipes.forEach(recipe => { const recipeItem = d.createElement('div'); recipeItem.className = 'recipe-item'; const modifiedDate = new Date(recipe.modified).toLocaleString(); const sizeKB = Math.round(recipe.size / 1024); recipeItem.innerHTML = ` <div class="recipe-info"> <div class="recipe-name">${recipe.filename}</div> <div class="recipe-meta">Modified: ${modifiedDate} | Size: ${sizeKB} KB</div> </div> <div class="recipe-actions"> <button class="btn-small btn-load" onclick="loadServerRecipe('${recipe.filename}')">Load</button> <button class="btn-small btn-delete" onclick="deleteServerRecipe('${recipe.filename}')">Delete</button> </div> `; recipesList.appendChild(recipeItem); }); } else { throw new Error(result.e || 'Failed to load recipes'); } } h (e) { c.e('Error loading recipes:', e); recipesList.innerHTML = '<p>Error loading recipes: ' + e.message + '</p>'; } } window.loadServerRecipe = async function(filename) { try { const r = await f(`/load-recipe/${filename}`); const result = await r.j(); if (r.ok) { applyRecipeSettings(result.data); alert('Recipe loaded successfully!'); hideModal('load-recipe-modal'); } else { throw new Error(result.e || 'Failed to load recipe'); } } h (e) { c.e('Error loading recipe:', e); alert('Error loading recipe: ' + e.message); } }; window.deleteServerRecipe = async function(filename) { if (!confirm(`Are you sure you want to delete "${filename}"?`)) { return; } try { const r = await f(`/delete-recipe/${filename}`, { method: 'DELETE' }); if (r.ok) { alert('Recipe deleted successfully!'); loadServerRecipes(); } else { const result = await r.j(); throw new Error(result.e || 'Failed to delete recipe'); } } h (e) { c.e('Error deleting recipe:', e); alert('Error deleting recipe: ' + e.message); } }; d.g('start').a('click', async () => { d.g('stop-overlay').classList.remove('active'); d.g('start-overlay').classList.add('active'); d.body.classList.remove('active-bg-stop'); d.body.classList.add('active-bg-start'); const data = { port: '/dev/serial0', frequency: parseInt(d.g('frequency-input').value) || 0, timer: { enabled: d.g('timer-toggle').checked, value: parseInt(d.g('timer-input').value) || 0 }, activeChannels: [], channels: {} }; if (data.timer.enabled && (data.timer.value < 0 || data.timer.value > 65534)) { alert('Delay start timer must be between 0 and 65534 ms'); return; } for (let channel = 1; channel <= 4; channel++) { const toggle = d.q(`.channel-toggle[data-channel="${channel}"]`); const isEnabled = toggle ? toggle.checked : false; if (isEnabled) { data.activeChannels.push(channel); data.channels[channel] = { pulseWidth: Number(d.q(`.pulse-width-input[data-channel="${channel}"]`).value), offset: Number(d.q(`.offset-input[data-channel="${channel}"]`).value), power: Number(d.q(`.power-input[data-channel="${channel}"]`).value), voltage: Number(d.q(`.voltage-input[data-channel="${channel}"]`).value) }; if (channel === 1) { const interlockToggle = d.q(`.interlock-toggle[data-channel="1"]`); data.channels[channel].interlock = interlockToggle ? interlockToggle.checked : false; } } } try { c.l('Sending updated data to server:', data); const r = await f('/start', { method: 'POST', headers: { 'Content-Type': 'application/j' }, body: JSON.stringify(data) }); const result = await r.j(); if (!r.ok) { throw new Error(result.e || 'Failed to start'); } d.g('stop').disabled = false; c.l('Data successfully sent to server'); } h (e) { c.e('Error starting:', e); alert(e.message || 'Error starting the generator'); } }); d.g('stop').a('click', async () => { d.g('start-overlay').classList.remove('active'); d.g('stop-overlay').classList.add('active'); d.body.classList.remove('active-bg-start'); d.body.classList.add('active-bg-stop'); try { const r = await f('/stop', { method: 'POST' }); let result = null; try { result = await r.j(); } h (e) { } if (!r.ok) { const msg = (result && result.e) ? result.e : 'Failed to stop'; alert('Ошибка при остановке: ' + msg); throw new Error(msg); } d.g('stop').disabled = true; } h (e) { c.e('Error stopping:', e); alert('Ошибка при остановке генератора: ' + (e.message || e)); } }); d.g('start').disabled = false; d.g('stop').disabled = true; d.qAll('.channel-toggle').forEach(toggle => { if (!toggle.checked) { const channelCard = toggle.closest('.channel-card'); const inputs = channelCard.qAll('input[type="text"]'); inputs.forEach(input => input.disabled = true); } }); d.g('timer-toggle').a('change', (e) => { const timerControl = e.target.closest('.timer-control'); const timerInput = d.g('timer-input'); timerInput.disabled = !e.target.checked; if (e.target.checked) { timerControl.classList.remove('disabled'); } else { timerControl.classList.add('disabled'); } }); const timerToggle = d.g('timer-toggle'); const timerControl = timerToggle.closest('.timer-control'); const timerInput = d.g('timer-input'); timerInput.disabled = !timerToggle.checked; if (timerToggle.checked) { timerControl.classList.remove('disabled'); } else { timerControl.classList.add('disabled'); } d.qAll('.channels-dropdown-toggle').forEach(btn => { btn.a('click', function(e) { const wrapper = btn.closest('.channels-dropdown-wrapper'); wrapper.classList.toggle('open'); }); }); d.a('click', function(e) { d.qAll('.channels-dropdown-wrapper.open').forEach(wrapper => { if (!wrapper.contains(e.target)) { wrapper.classList.remove('open'); } }); }); function updateChannelsDropdownValues() { d.qAll('.channels-dropdown-wrapper').forEach(wrapper => { const valuesSpan = wrapper.q('.channels-dropdown-values'); const checkboxes = wrapper.qAll('.channels-dropdown-list input[type="checkbox"]'); const selected = Array.from(checkboxes) .map((cb, idx) => cb.checked ? (2 + idx) : null) .filter(Boolean); if (selected.length > 0) { valuesSpan.textContent = selected.join(','); } else { valuesSpan.textContent = 'select'; } }); } d.qAll('.channels-dropdown-list input[type="checkbox"]').forEach(cb => { cb.a('change', updateChannelsDropdownValues); }); updateChannelsDropdownValues(); d.qAll('.channels-dropdown-selected').forEach(box => { box.a('click', function(e) { const wrapper = box.closest('.channels-dropdown-wrapper'); wrapper.classList.toggle('open'); }); box.a('keydown', function(e) { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); const wrapper = box.closest('.channels-dropdown-wrapper'); wrapper.classList.toggle('open'); } }); }); d.a('click', function(e) { d.qAll('.channels-dropdown-wrapper.open').forEach(wrapper => { if (!wrapper.contains(e.target)) { wrapper.classList.remove('open'); } }); }); const pulseWidth1 = d.q('.pulse-width-input[data-channel="1"]'); const offset1 = d.q('.offset-input[data-channel="1"]'); const offset2 = d.q('.offset-input[data-channel="2"]'); const pulseWidth3 = d.q('.pulse-width-input[data-channel="3"]'); const offset3 = d.q('.offset-input[data-channel="3"]'); const offset4 = d.q('.offset-input[data-channel="4"]'); pulseWidth1.a('input', updateOffset2Min); offset1.a('input', updateOffset2Min); updateOffset2Min(); pulseWidth3.a('input', updateOffset4Min); offset3.a('input', updateOffset4Min); updateOffset4Min(); offset2.a('input', function() { const pw1 = parseFloat(pulseWidth1.value); const off1 = parseFloat(offset1.value); const safePw1 = isNaN(pw1) ? 0 : pw1; const safeOff1 = isNaN(off1) ? 0 : off1; const interlock = parseFloat(d.g('interlock-input').value) || 0; const minVal = safePw1 + safeOff1 + interlock; if (parseFloat(offset2.value) < minVal || offset2.value === '') { offset2.value = minVal; offset2.dispatchEvent(new Event('input')); return; } if (window.previewActive) { const channelCard = offset2.closest('.channel-card'); const pulseDisplay = channelCard.q('.pulse-display'); const channel = pulseDisplay.dataset.channel; const canvas = pulseDisplay.q('.pulse-chart'); const pulseWidthInput = channelCard.q('.pulse-width-input'); const periodInput = d.g('period-input'); const pulseWidth = parseFloat(pulseWidthInput.value) || 0; const offset = parseFloat(offset2.value) || 0; const period = parseFloat(periodInput.value) || 1000; const channelNum = parseInt(channel); const reverse = (channelNum === 2 || channelNum === 4); drawPulseChart(canvas, pulseWidth, offset, period, null, reverse); } }); offset4.a('input', function() { const pw3 = parseFloat(pulseWidth3.value); const off3 = parseFloat(offset3.value); const safePw3 = isNaN(pw3) ? 0 : pw3; const safeOff3 = isNaN(off3) ? 0 : off3; const interlock = parseFloat(d.g('interlock-input').value) || 0; const minVal = safePw3 + safeOff3 + interlock; if (parseFloat(offset4.value) < minVal || offset4.value === '') { offset4.value = minVal; offset4.dispatchEvent(new Event('input')); return; } if (window.previewActive) { const channelRow = offset4.closest('.channel-row'); const mainInputDiv = channelRow.q('.main-channel-input, .main-channel-input-1'); const channel = mainInputDiv.dataset.channel; const canvas = mainInputDiv.q('.pulse-chart'); const pulseWidthInput = channelRow.q('.pulse-width-input'); const periodInput = d.g('period-input'); const pulseWidth = parseFloat(pulseWidthInput.value) || 0; const offset = parseFloat(offset4.value) || 0; const period = parseFloat(periodInput.value) || 1000; const channelNum = parseInt(channel); const reverse = (channelNum === 2 || channelNum === 4); drawPulseChart(canvas, pulseWidth, offset, period, null, reverse); } }); const slider1 = d.q('.channel-toggle[data-channel="1"]').nextElementSibling; if (slider1) slider1.classList.add('slider-channel-1'); const slider3 = d.q('.channel-toggle[data-channel="3"]').nextElementSibling; if (slider3) slider3.classList.add('slider-channel-3'); const slider2 = d.q('.channel-toggle[data-channel="2"]').nextElementSibling; if (slider2) slider2.classList.add('slider-channel-2'); const slider4 = d.q('.channel-toggle[data-channel="4"]').nextElementSibling; if (slider4) slider4.classList.add('slider-channel-4'); d.g('period-input').value = '1000'; d.g('period-input').setAttribute('inputmode', 'decimal'); d.g('period-input').setAttribute('pattern', '[0-9.]*'); const period = 1000.00; const frequency = (1 / period) * 1000000; d.g('frequency-input').value = frequency.toFixed(2); d.g('interlock-input').value = '5'; d.qAll('.channel-card').forEach(channelCard => { channelCard.q('.pulse-width-input').value = '10'; channelCard.q('.offset-input').value = '10'; channelCard.q('.power-input').value = '10'; channelCard.q('.voltage-input').value = '10'; }); updateOffset2Min(); updateOffset4Min(); function resizeCanvasToDisplaySize(canvas) { const parent = canvas.parentElement; const style = getComputedStyle(parent); const width = Math.round(parseFloat(style.width)); const height = Math.round(parseFloat(style.height)); if (canvas.width !== width || canvas.height !== height) { canvas.width = width; canvas.height = height; return true; } return false; } function getPulseData(pulseWidth, offset, period=1000, repeat=3, reverse=false, maxX=Infinity) { const data = []; if (pulseWidth < 0 || offset < 0 || period <= 0) { c.l('Invalid input data:', {pulseWidth, offset, period}); return data; } const maxRepeat = Math.min(repeat, 20); c.l(`getPulseData called with: pulseWidth=${pulseWidth}, offset=${offset}, period=${period}, repeat=${repeat}, maxRepeat=${maxRepeat}, maxX=${maxX}`); for (let n = 0; n < maxRepeat; n++) { const base = n * period; let points; if (!reverse) { points = [ {x: base + 0, y: 0}, {x: base + offset, y: 0}, {x: base + offset, y: 1}, {x: base + offset + pulseWidth, y: 1}, {x: base + offset + pulseWidth, y: 0}, {x: base + period, y: 0} ]; } else { points = [ {x: base + 0, y: 1}, {x: base + offset, y: 1}, {x: base + offset, y: 0}, {x: base + offset + pulseWidth, y: 0}, {x: base + offset + pulseWidth, y: 1}, {x: base + period, y: 1} ]; } for (const pt of points) { if (pt.x <= maxX) { data.push(pt); } else { if (data.length > 0) { data.push({x: maxX, y: data[data.length-1].y}); } c.l(`Data truncated at maxX=${maxX}, generated ${data.length} points`); return data; } } } c.l(`Generated ${data.length} points for ${maxRepeat} repeats`); return data; } function drawPulseChart(canvas, pulseWidth, offset, period=1000, repeat=3, reverse=false) { if (isNaN(pulseWidth) || isNaN(offset) || isNaN(period) || pulseWidth < 0 || offset < 0 || period <= 0) { c.l('Invalid input data, skipping chart update'); return; } resizeCanvasToDisplaySize(canvas); const width = canvas.width; let showRepeat = 3; if (repeat === null) { const totalPulseWidth = pulseWidth + offset; if (totalPulseWidth < period * 0.5) { showRepeat = 5; } else if (totalPulseWidth < period * 0.7) { showRepeat = 3; } else if (totalPulseWidth < period) { showRepeat = 2; } else { showRepeat = 1; } c.l(`Simple calculation: totalPulse=${totalPulseWidth}, period=${period}, showRepeat=${showRepeat}`); } else { showRepeat = repeat; } let scaleFactor = 1; let maxX = period * showRepeat; if (maxX > width) { scaleFactor = width / maxX; maxX = width; } const scaledPulseWidth = pulseWidth * scaleFactor; const scaledOffset = offset * scaleFactor; const scaledPeriod = period * scaleFactor; c.l(`Final: pulse=${scaledPulseWidth}, offset=${scaledOffset}, period=${scaledPeriod}, repeat=${showRepeat}, maxX=${maxX}`); if (canvas._chart) { canvas._chart.destroy(); } const chartData = getPulseData(scaledPulseWidth, scaledOffset, scaledPeriod, showRepeat, reverse, maxX); canvas._chart = new Chart(canvas.getContext('2d'), { type: 'line', data: { datasets: [{ label: '', data: chartData, borderColor: '#e91e1e', borderWidth: 1, fill: false, pointRadius: 0, stepped: true, }] }, options: { animation: false, responsive: false, plugins: { legend: { display: false } }, scales: { x: { type: 'linear', min: 0, max: maxX, display: false }, y: { min: -0.1, max: 1.1, display: false } } } }); c.l(`Chart updated with ${chartData.length} points`); } function drawPulseChart1(canvas1, pulseWidth, offset, period=1000, repeat=3, reverse=false) { if (isNaN(pulseWidth) || isNaN(offset) || isNaN(period) || pulseWidth < 0 || offset < 0 || period <= 0) { c.l('Invalid input data for canvas1, skipping chart update'); return; } resizeCanvasToDisplaySize(canvas1); const width = canvas1.width; let showRepeat = 3; if (repeat === null) { const totalPulseWidth = pulseWidth + offset; if (totalPulseWidth < period * 0.3) { showRepeat = 5; } else if (totalPulseWidth < period * 0.7) { showRepeat = 3; } else if (totalPulseWidth < period) { showRepeat = 2; }else { showRepeat = 1; } c.l(`Canvas1 calculation: totalPulse=${totalPulseWidth}, period=${period}, showRepeat=${showRepeat}`); } else { showRepeat = repeat; } let scaleFactor = 1; let maxX = period * showRepeat; if (maxX > width * 0.9) { scaleFactor = (width * 0.9) / maxX; maxX = width * 0.9; } const scaledPulseWidth = pulseWidth * scaleFactor; const scaledOffset = offset * scaleFactor; const scaledPeriod = period * scaleFactor; c.l(`Canvas1 final: pulse=${scaledPulseWidth}, offset=${scaledOffset}, period=${scaledPeriod}, repeat=${showRepeat}, maxX=${maxX}`); if (canvas1._chart) { canvas1._chart.destroy(); } const chartData = getPulseData(scaledPulseWidth, scaledOffset, scaledPeriod, showRepeat, reverse, maxX); canvas1._chart = new Chart(canvas1.getContext('2d'), { type: 'line', data: { datasets: [{ label: '', data: chartData, borderColor: '#4c5baf', borderWidth: 2, fill: false, pointRadius: 0, stepped: true, }] }, options: { animation: false, responsive: false, plugins: { legend: { display: false } }, scales: { x: { type: 'linear', min: 0, max: maxX, display: false }, y: { min: -0.1, max: 1.1, display: false } } } }); c.l(`Canvas1 chart updated with ${chartData.length} points`); } d.qAll('.channel-card').forEach(channelCard => { const pulseDisplay = channelCard.q('.pulse-display'); const channel = pulseDisplay.dataset.channel; const channelNum = parseInt(channel); if (channelNum === 1 || channelNum === 3) { const canvas = pulseDisplay.q('.pulse-chart'); const mainInput = pulseDisplay.q('.pulse-value'); const pulseWidthInput = channelCard.q('.pulse-width-input'); const offsetInput = channelCard.q('.offset-input'); const periodInput = d.g('period-input'); function updateChart() { if (!window.previewActive) return; const pulseWidth = parseFloat(pulseWidthInput.value) || 0; const offset = parseFloat(offsetInput.value) || 0; const period = parseFloat(periodInput.value) || 1000; const reverse = true; c.l(`updateChart called for channel ${channelNum}: pulseWidth=${pulseWidth}, offset=${offset}, period=${period}`); drawPulseChart(canvas, pulseWidth, offset, period, null, reverse); } pulseWidthInput.a('input', updateChart); offsetInput.a('input', updateChart); periodInput.a('input', updateChart); } }); d.qAll('.channel-card').forEach(channelCard => { const pulseDisplay = channelCard.q('.pulse-display'); const channel = pulseDisplay.dataset.channel; const channelNum = parseInt(channel); if (channelNum === 2 || channelNum === 4) { const canvas1 = pulseDisplay.q('.pulse-chart'); const mainInput = pulseDisplay.q('.pulse-value'); const pulseWidthInput = channelCard.q('.pulse-width-input'); const offsetInput = channelCard.q('.offset-input'); const periodInput = d.g('period-input'); function updateChart() { if (!window.previewActive) return; const pulseWidth = parseFloat(pulseWidthInput.value) || 0; const offset = parseFloat(offsetInput.value) || 0; const period = parseFloat(periodInput.value) || 1000; const reverse = false; c.l(`updateChart called for channel ${channelNum} (REVERSE): pulseWidth=${pulseWidth}, offset=${offset}, period=${period}`); drawPulseChart1(canvas1, pulseWidth, offset, period, null, reverse); } pulseWidthInput.a('input', updateChart); offsetInput.a('input', updateChart); periodInput.a('input', updateChart); } }); const previewBtn = d.g('preview-recipe'); window.previewActive = false; function setPreviewState(active) { window.previewActive = active; d.qAll('.pulse-display').forEach(pulseDisplay => { const canvas = pulseDisplay.q('.pulse-chart'); if (canvas) canvas.style.display = active ? '' : 'none'; }); previewBtn.textContent = active ? 'Hide Preview' : 'Preview'; previewBtn.style.background = active ? '#2196F3' : ''; previewBtn.style.color = active ? '#fff' : ''; } previewBtn.a('click', () => { window.previewActive = !window.previewActive; setPreviewState(window.previewActive); if (window.previewActive) { d.qAll('.pulse-display').forEach(pulseDisplay => { const channel = pulseDisplay.dataset.channel; const canvas = pulseDisplay.q('.pulse-chart'); const channelCard = pulseDisplay.closest('.channel-card'); const pulseWidthInput = channelCard.q('.pulse-width-input'); const offsetInput = channelCard.q('.offset-input'); const periodInput = d.g('period-input'); const pulseWidth = parseFloat(pulseWidthInput.value) || 0; const offset = parseFloat(offsetInput.value) || 0; const period = parseFloat(periodInput.value) || 1000; const channelNum = parseInt(channel); const reverse = (channelNum === 1 || channelNum === 3); if (channelNum === 2 || channelNum === 4) { drawPulseChart1(canvas, pulseWidth, offset, period, null, reverse); } else { drawPulseChart(canvas, pulseWidth, offset, period, null, reverse); } }); } }); setPreviewState(false); d.g('interlock-input').a('input', function() { updateOffset2Min(); updateOffset4Min(); }); });